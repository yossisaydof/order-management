package com.yotpo.orders.domain.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.OffsetDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * Retry queue entry for orders that failed to publish to Kafka.
 *
 * Purpose:
 * - High availability: API always returns 202 Accepted
 * - If Kafka is down, orders are queued for retry
 * - Background job retries with exponential backoff
 *
 * Lifecycle:
 * 1. API tries to publish to Kafka
 * 2. On failure, order is inserted into retry_queue
 * 3. Background job (every 5s) retries pending entries
 * 4. On success, entry is deleted from queue
 * 5. On failure, retry_count++ and next_retry_at updated
 */
@Entity
@Table(name = "retry_queue")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RetryQueueEntry {

    /**
     * Primary key - auto-generated UUID.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", nullable = false, updatable = false)
    private UUID id;

    /**
     * Order ID (UUID generated by API).
     * Used for logging and correlation.
     */
    @Column(name = "order_id", nullable = false)
    private UUID orderId;

    /**
     * Store ID (partition key for Kafka).
     */
    @Column(name = "store_id", nullable = false, length = 255)
    private String storeId;

    /**
     * Complete Kafka message payload (JSON).
     * Contains all order data needed for retry.
     * Stored as JSONB in PostgreSQL.
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "message_payload", nullable = false, columnDefinition = "jsonb")
    private Map<String, Object> messagePayload;

    /**
     * Number of retry attempts so far.
     */
    @Column(name = "retry_count", nullable = false)
    @Builder.Default
    private Integer retryCount = 0;

    /**
     * When this entry was created.
     */
    @Column(name = "created_at", nullable = false)
    private OffsetDateTime createdAt;

    /**
     * When to attempt next retry (exponential backoff).
     */
    @Column(name = "next_retry_at", nullable = false)
    private OffsetDateTime nextRetryAt;

    /**
     * Last error message (for debugging).
     */
    @Column(name = "last_error", columnDefinition = "TEXT")
    private String lastError;

    /**
     * Set creation timestamp before persisting.
     */
    @PrePersist
    protected void onCreate() {
        if (this.createdAt == null) {
            this.createdAt = OffsetDateTime.now();
        }
        if (this.nextRetryAt == null) {
            this.nextRetryAt = OffsetDateTime.now();
        }
    }

    /**
     * Increment retry count and calculate next retry time with exponential backoff.
     *
     * @param baseDelaySeconds base delay in seconds (e.g., 5)
     * @param maxDelaySeconds maximum delay cap in seconds (e.g., 300)
     */
    public void incrementRetryWithBackoff(int baseDelaySeconds, int maxDelaySeconds) {
        this.retryCount++;
        // Exponential backoff: base * 2^(retryCount-1), capped at maxDelay
        long delaySeconds = Math.min(
            (long) baseDelaySeconds * (1L << (this.retryCount - 1)),
            maxDelaySeconds
        );
        this.nextRetryAt = OffsetDateTime.now().plusSeconds(delaySeconds);
    }
}
